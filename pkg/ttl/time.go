package ttl

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/tj/go-naturaldate"
)

var daysPattern = regexp.MustCompile(`^(\d+)d$`)
var humanDurationPattern = regexp.MustCompile(`^(\d+)\s+(seconds?|secs?|minutes?|mins?|hours?|hrs?|days?|weeks?)$`)

// maxTTLDuration is the maximum TTL (~11 months) since cron has no year field.
const maxTTLDuration = 11 * 30 * 24 * time.Hour

// ParseTimeInput parses a time input string and returns an absolute time.
// It tries these formats in order:
// 1. Go durations: 30m, 2h, 2h30m, 24h, 168h
// 2. Days shorthand: 7d, 30d
// 3. Human-readable durations: 6 hours, 3 days, 2 weeks, 30 mins
// 4. Natural language: tomorrow, next monday, in 2 hours
func ParseTimeInput(input string, now time.Time) (time.Time, error) {
	// Try Go duration
	if d, err := time.ParseDuration(input); err == nil {
		if d <= 0 {
			return time.Time{}, fmt.Errorf("duration must be positive, got %s", input)
		}

		target := now.Add(d)
		if target.Sub(now) > maxTTLDuration {
			return time.Time{}, fmt.Errorf("TTL exceeds maximum of ~11 months")
		}

		return target, nil
	}

	// Try days shorthand (e.g., 7d, 30d)
	if matches := daysPattern.FindStringSubmatch(input); matches != nil {
		days, err := strconv.Atoi(matches[1])
		if err != nil {
			return time.Time{}, fmt.Errorf("invalid days value: %s", matches[1])
		}

		if days <= 0 {
			return time.Time{}, fmt.Errorf("days must be positive, got %d", days)
		}

		target := now.Add(time.Duration(days) * 24 * time.Hour)
		if target.Sub(now) > maxTTLDuration {
			return time.Time{}, fmt.Errorf("TTL exceeds maximum of ~11 months")
		}

		return target, nil
	}

	// Try human-readable duration (e.g., "6 hours", "3 days", "2 weeks")
	if matches := humanDurationPattern.FindStringSubmatch(input); matches != nil {
		value, err := strconv.Atoi(matches[1])
		if err != nil {
			return time.Time{}, fmt.Errorf("invalid duration value: %s", matches[1])
		}

		if value <= 0 {
			return time.Time{}, fmt.Errorf("duration must be positive, got %d %s", value, matches[2])
		}

		unit := parseHumanDurationUnit(matches[2])
		target := now.Add(time.Duration(value) * unit)
		if target.Sub(now) > maxTTLDuration {
			return time.Time{}, fmt.Errorf("TTL exceeds maximum of ~11 months")
		}

		return target, nil
	}

	// Try natural language
	target, err := naturaldate.Parse(input, now)
	if err != nil {
		return time.Time{}, fmt.Errorf("could not parse time input %q: %w", input, err)
	}

	if !target.After(now) {
		return time.Time{}, fmt.Errorf("parsed time %s is not in the future", target.Format(time.RFC3339))
	}

	if target.Sub(now) > maxTTLDuration {
		return time.Time{}, fmt.Errorf("TTL exceeds maximum of ~11 months")
	}

	return target, nil
}

// parseHumanDurationUnit maps a human-readable unit word to a time.Duration.
func parseHumanDurationUnit(unit string) time.Duration {
	switch {
	case strings.HasPrefix(unit, "sec"):
		return time.Second
	case strings.HasPrefix(unit, "min"):
		return time.Minute
	case strings.HasPrefix(unit, "hour"), strings.HasPrefix(unit, "hr"):
		return time.Hour
	case strings.HasPrefix(unit, "day"):
		return 24 * time.Hour
	case strings.HasPrefix(unit, "week"):
		return 7 * 24 * time.Hour
	default:
		return time.Second
	}
}

// TimeToCronSchedule converts an absolute time to a cron schedule string.
// Format: M H D Mon * (minute, hour, day-of-month, month, day-of-week)
func TimeToCronSchedule(t time.Time) string {
	return fmt.Sprintf("%d %d %d %d *", t.Minute(), t.Hour(), t.Day(), t.Month())
}

// ParseCronSchedule parses a cron schedule string back to a time.Time.
// It assumes the schedule was generated by TimeToCronSchedule and uses
// the current year (or next year if the date has passed).
func ParseCronSchedule(schedule string) (time.Time, error) {
	var minute, hour, day, month int
	var dow string

	n, err := fmt.Sscanf(schedule, "%d %d %d %d %s", &minute, &hour, &day, &month, &dow)
	if err != nil || n != 5 {
		return time.Time{}, fmt.Errorf("invalid cron schedule %q: expected format 'M H D Mon *'", schedule)
	}

	now := time.Now()
	t := time.Date(now.Year(), time.Month(month), day, hour, minute, 0, 0, now.Location())

	// If the time is in the past, try next year
	if t.Before(now) {
		t = time.Date(now.Year()+1, time.Month(month), day, hour, minute, 0, 0, now.Location())
	}

	return t, nil
}
